// TypeScript interfaces
interface ServiceDetail {
  serviceName: string;
  [key: string]: any; // Allow for flexible attributes
}

interface ServiceStats {
  totalServices: number;
  uniqueServiceNames: number;
  uniqueServiceNamesList: string[];
  attributeCountByService: Record<string, number>;
  totalAttributes: number;
  averageAttributesPerService: number;
  allAttributeKeys: string[];
  serviceNameFrequency: Record<string, number>;
}

// Service Statistics Calculator Class
class ServiceStatsCalculator {
  private serviceData: ServiceDetail[];

  constructor(serviceData: ServiceDetail[]) {
    this.serviceData = serviceData;
  }

  public calculateStats(): ServiceStats {
    if (this.serviceData.length === 0) {
      return this.getEmptyStats();
    }

    const serviceNames = this.extractServiceNames();
    const uniqueServiceNames = this.getUniqueServiceNames(serviceNames);
    const serviceNameFrequency = this.calculateServiceNameFrequency(serviceNames);
    const { attributeCountByService, allAttributeKeys } = this.calculateAttributesByService(uniqueServiceNames);
    const totalAttributes = this.calculateTotalAttributes(attributeCountByService);

    return {
      totalServices: this.serviceData.length,
      uniqueServiceNames: uniqueServiceNames.length,
      uniqueServiceNamesList: uniqueServiceNames,
      attributeCountByService,
      totalAttributes,
      averageAttributesPerService: totalAttributes / uniqueServiceNames.length || 0,
      allAttributeKeys,
      serviceNameFrequency
    };
  }

  private getEmptyStats(): ServiceStats {
    return {
      totalServices: 0,
      uniqueServiceNames: 0,
      uniqueServiceNamesList: [],
      attributeCountByService: {},
      totalAttributes: 0,
      averageAttributesPerService: 0,
      allAttributeKeys: [],
      serviceNameFrequency: {}
    };
  }

  private extractServiceNames(): string[] {
    return this.serviceData.map(service => service.serviceName);
  }

  private getUniqueServiceNames(serviceNames: string[]): string[] {
    return [...new Set(serviceNames)];
  }

  private calculateServiceNameFrequency(serviceNames: string[]): Record<string, number> {
    return serviceNames.reduce((acc, name) => {
      acc[name] = (acc[name] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);
  }

  private calculateAttributesByService(uniqueServiceNames: string[]): {
    attributeCountByService: Record<string, number>;
    allAttributeKeys: string[];
  } {
    const attributeCountByService: Record<string, number> = {};
    const allAttributeKeysSet = new Set<string>();

    uniqueServiceNames.forEach(serviceName => {
      const servicesWithName = this.serviceData.filter(service => service.serviceName === serviceName);
      const allAttributesForService = new Set<string>();
      
      servicesWithName.forEach(service => {
        Object.keys(service).forEach(key => {
          if (key !== 'serviceName') {
            allAttributesForService.add(key);
            allAttributeKeysSet.add(key);
          }
        });
      });
      
      attributeCountByService[serviceName] = allAttributesForService.size;
    });

    return {
      attributeCountByService,
      allAttributeKeys: Array.from(allAttributeKeysSet)
    };
  }

  private calculateTotalAttributes(attributeCountByService: Record<string, number>): number {
    return Object.values(attributeCountByService).reduce((sum, count) => sum + count, 0);
  }

  // Static method for one-time calculations
  static calculateServiceStats(serviceData: ServiceDetail[]): ServiceStats {
    const calculator = new ServiceStatsCalculator(serviceData);
    return calculator.calculateStats();
  }
}
