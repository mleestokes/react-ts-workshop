// Custom hook for managing LegacyIndex
function useLegacyIndex(legacyData: Legacy[]) {
  const [isIndexing, setIsIndexing] = useState(false);
  const indexRef = useRef<LegacyIndex | null>(null);

  // Create index when data changes
  useEffect(() => {
    if (legacyData.length === 0) {
      indexRef.current = null;
      return;
    }

    setIsIndexing(true);
    
    // For very large datasets, use setTimeout to prevent blocking
    const createIndex = () => {
      try {
        indexRef.current = new LegacyIndex(legacyData);
      } catch (error) {
        console.error('Failed to create legacy index:', error);
        indexRef.current = null;
      } finally {
        setIsIndexing(false);
      }
    };

    if (legacyData.length > 10000) {
      // Use timeout for large datasets to prevent UI blocking
      setTimeout(createIndex, 0);
    } else {
      createIndex();
    }
  }, [legacyData]);

  // Memoized calculation functions
  const sumReposInScope = useCallback((targetIds: (string | number)[]) => {
    return indexRef.current?.sumReposInScopeByIds(targetIds) ?? 0;
  }, []);

  const getStats = useCallback((targetIds: (string | number)[]) => {
    return indexRef.current?.getStatsByIds(targetIds) ?? {
      totalInScope: 0,
      totalCompleted: 0,
      totalRepos: 0,
      foundCount: 0,
      notFoundCount: targetIds.length
    };
  }, []);

  const getLegacy = useCallback((id: string | number) => {
    return indexRef.current?.getLegacyById(id);
  }, []);

  return {
    isIndexing,
    isReady: !isIndexing && indexRef.current !== null,
    sumReposInScope,
    getStats,
    getLegacy,
    index: indexRef.current
  };
}
